<!DOCTYPE html><html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HandMusic ¬∑ Control musical por manos (Webcam + MediaPipe)</title>
  <style>
    :root{
      --bg:#0b0d12; --panel:#131722; --ink:#e9eef8; --muted:#9aa6b2; --acc:#5ae; --good:#42d392; --warn:#ffb020; --bad:#ff4d4f;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px;height:100%;}
    .left{background:var(--panel);border-radius:16px;padding:16px;overflow:auto;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .right{position:relative;border-radius:16px;overflow:hidden;background:#000;}
    h1{font-size:20px;margin:0 0 8px 0}
    h2{font-size:14px;color:var(--muted);font-weight:600;margin:16px 0 8px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
    label{display:block;font-size:13px;margin:6px 0 4px;color:var(--muted)}
    select,button,input[type="range"]{width:100%;padding:10px;border-radius:10px;border:1px solid #223;outline:none;background:#0f1320;color:var(--ink)}
    button.primary{background:linear-gradient(180deg,#2a6cff,#1f4dd9);border:none;font-weight:600;cursor:pointer}
    button.ghost{background:#0f1320;border:1px solid #223;cursor:pointer}
    .small{font-size:12px;color:var(--muted)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0f1320;border:1px solid #223;font-size:12px;color:var(--muted)}
    .video-wrap{position:relative;height:100%}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    canvas{pointer-events:none}
    .hud{position:absolute;left:12px;bottom:12px;display:flex;gap:8px;align-items:center}
    .led{width:10px;height:10px;border-radius:50%}
    .led.ok{background:var(--good)}
    .led.warn{background:var(--warn)}
    .led.bad{background:var(--bad)}
    details{border:1px solid #223;border-radius:10px;padding:8px;background:#0f1320}
    details summary{cursor:pointer;font-weight:600;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .degree{display:grid;grid-template-columns:1.1fr .9fr .9fr;gap:8px;align-items:end}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0f1320;border:1px solid #223;border-radius:8px;padding:2px 6px;font-size:12px;color:#bcd}
    .notice{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <aside class="left">
      <h1>HandMusic <span class="pill">Webcam + Seguimiento de manos</span></h1>
      <p class="small">Abre/cierra la mano y mueve cada dedo: cada dedo dispara una nota. El movimiento vertical del dedo modifica el tono en tiempo real. Cambia de instrumento, tonalidad y asignaciones sin parar el flujo.</p><h2>Inicio</h2>
  <div class="row">
    <button id="btnStart" class="primary">‚ñ∂ Activar c√°mara y audio</button>
    <button id="btnMute" class="ghost" disabled>üîá Silencio</button>
  </div>
  <div class="row" style="margin-top:8px">
    <div class="pill"><span id="permStatusLed" class="led bad"></span> <span id="permStatus">Permisos no concedidos</span></div>
    <div class="pill"><span id="fpsLed" class="led warn"></span> <span id="fpsText">FPS: ‚Äî</span></div>
  </div>

  <h2>Instrumento</h2>
  <div class="row">
    <div>
      <label for="instrumentSel">Tipo</label>
      <select id="instrumentSel">
        <option value="piano" selected>Piano (envelope percutivo)</option>
        <option value="guitarra">Guitarra (ataque corto)</option>
        <option value="violin">Viol√≠n (sustain)</option>
        <option value="sintetizador">Sintetizador (saw LP)</option>
        <option value="squarelead">Square Lead</option>
      </select>
    </div>
    <div>
      <label for="latencyRange">Buffer (ms) ¬∑ menor = menos latencia</label>
      <input type="range" id="latencyRange" min="0" max="30" value="5" />
    </div>
  </div>

  <h2>Tonalidad global</h2>
  <div class="row3">
    <div>
      <label for="rootSel">T√≥nica</label>
      <select id="rootSel"></select>
    </div>
    <div>
      <label for="modeSel">Modo</label>
      <select id="modeSel">
        <option value="major" selected>Mayor</option>
        <option value="minor">Menor</option>
        <option value="dorian">D√≥rico</option>
        <option value="pentatonic">Pentat√≥nica mayor</option>
      </select>
    </div>
    <div>
      <label for="octaveSel">Octava base</label>
      <select id="octaveSel">
        <option value="3">3</option>
        <option value="4" selected>4</option>
        <option value="5">5</option>
      </select>
    </div>
  </div>

  <h2>Asignaci√≥n por dedo (grados de escala)</h2>
  <div id="fingersConfig" class="grid"></div>
  <p class="notice">Consejo: <span class="kbd">Pulgar‚Üí1</span>, <span class="kbd">√çndice‚Üí2</span>, <span class="kbd">Medio‚Üí3</span>, <span class="kbd">Anular‚Üí5</span>, <span class="kbd">Me√±ique‚Üí6</span> da una sonoridad pentat√≥nica musical y f√°cil de controlar.</p>

  <details>
    <summary>Avanzado: tonalidad por dedo (opcional)</summary>
    <div id="advancedOverride" class="grid" style="margin-top:8px"></div>
    <p class="notice">Activa una tonalidad propia por dedo si quieres que ignore la tonalidad global.</p>
  </details>

  <h2>Expresividad</h2>
  <div class="row3">
    <div>
      <label for="bendRange">Rango bend (semitonos)</label>
      <input type="range" id="bendRange" min="0" max="12" value="4" />
    </div>
    <div>
      <label for="vibRange">Vibrato auto (Hz)</label>
      <input type="range" id="vibRange" min="0" max="8" value="0" />
    </div>
    <div>
      <label for="gainRange">Volumen</label>
      <input type="range" id="gainRange" min="0" max="1" step="0.01" value="0.85" />
    </div>
  </div>
  <p class="small">Vertical del dedo = bend (‚Üë sube, ‚Üì baja). Velocidad vertical = ataque m√°s fuerte. Cierra la mano para silenciar r√°pidamente.</p>

  <h2>Estado</h2>
  <div class="small" id="stateText">‚Äî</div>
  <p class="notice">Si necesitas usarlo 100% offline, descarga los assets de MediaPipe y cambia la ruta en <span class="kbd">locateFile</span>.</p>
</aside>

<section class="right">
  <div class="video-wrap">
    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
    <div class="hud">
      <span class="pill">Manos detectadas: <strong id="handsCount">0</strong></span>
      <span class="pill">Instrumento: <strong id="hudInstr">Piano</strong></span>
    </div>
  </div>
</section>

  </div>  <!-- MediaPipe (se cargan desde CDN). Mantener en un solo HTML: sin build. -->  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>  <script>
  (function(){
    // ===== Utilidades musicales =====
    const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const MODES = {
      major: [0,2,4,5,7,9,11],
      minor: [0,2,3,5,7,8,10],
      dorian:[0,2,3,5,7,9,10],
      pentatonic:[0,2,4,7,9]
    };
    const FINGER_NAMES = ["Pulgar","√çndice","Medio","Anular","Me√±ique"];
    const TIP = [4,8,12,16,20];
    const PIP = [3,6,10,14,18]; // para pulgar usamos 3 (IP) como referencia

    // Llenar selects de notas
    const rootSel = document.getElementById('rootSel');
    NOTE_NAMES.forEach((n,i)=>{
      const o = document.createElement('option'); o.value = i; o.textContent = n; if(i===0) o.selected=true; rootSel.appendChild(o);
    });

    // Config por dedo (grado + octava)
    const fingersConfigEl = document.getElementById('fingersConfig');
    const degreeDefaults = [1,2,3,5,6];
    const perFinger = degreeDefaults.map((deg,i)=>({degree:deg, octaveShift:0, override:false, overrideRoot:0, overrideMode:'major'}));

    function buildFingersUI(){
      fingersConfigEl.innerHTML='';
      perFinger.forEach((cfg,i)=>{
        const box = document.createElement('div');
        box.className='degree';
        box.innerHTML = `
          <div>
            <label>${FINGER_NAMES[i]} ¬∑ Grado</label>
            <select data-type="degree" data-idx="${i}">
              ${Array.from({length:7},(_,k)=>`<option value="${k+1}" ${cfg.degree===(k+1)?'selected':''}>${k+1}</option>`).join('')}
            </select>
          </div>
          <div>
            <label>Octava</label>
            <select data-type="oct" data-idx="${i}">
              <option value="-1" ${cfg.octaveShift===-1?'selected':''}>-1</option>
              <option value="0" ${cfg.octaveShift===0?'selected':''}>0</option>
              <option value="1" ${cfg.octaveShift===1?'selected':''}>+1</option>
            </select>
          </div>
          <div>
            <label>Override</label>
            <select data-type="ovr" data-idx="${i}">
              <option value="off" ${!cfg.override?'selected':''}>No</option>
              <option value="on" ${cfg.override?'selected':''}>S√≠</option>
            </select>
          </div>`;
        fingersConfigEl.appendChild(box);
      });
    }
    buildFingersUI();

    const advEl = document.getElementById('advancedOverride');
    function buildAdvancedUI(){
      advEl.innerHTML='';
      perFinger.forEach((cfg,i)=>{
        const box = document.createElement('div');
        box.innerHTML = `
          <label>${FINGER_NAMES[i]} ¬∑ T√≥nica/Modo</label>
          <div class="row">
            <select data-type="ovrRoot" data-idx="${i}">
              ${NOTE_NAMES.map((n,ii)=>`<option value="${ii}" ${cfg.overrideRoot===ii?'selected':''}>${n}</option>`).join('')}
            </select>
            <select data-type="ovrMode" data-idx="${i}">
              ${Object.keys(MODES).map(m=>`<option value="${m}" ${cfg.overrideMode===m?'selected':''}>${labelMode(m)}</option>`).join('')}
            </select>
          </div>`;
        advEl.appendChild(box);
      });
    }
    buildAdvancedUI();

    function labelMode(m){
      return {major:'Mayor', minor:'Menor', dorian:'D√≥rico', pentatonic:'Pentat√≥nica'}[m]||m;
    }

    function attachConfigHandlers(){
      document.addEventListener('change', (e)=>{
        const t = e.target; if(!t.dataset || t.dataset.idx===undefined) return;
        const idx = +t.dataset.idx; const type = t.dataset.type; const val = t.value;
        const cfg = perFinger[idx];
        if(type==='degree') cfg.degree = +val;
        else if(type==='oct') cfg.octaveShift = +val;
        else if(type==='ovr') cfg.override = (val==='on');
        else if(type==='ovrRoot') cfg.overrideRoot = +val;
        else if(type==='ovrMode') cfg.overrideMode = val;
      });
    }
    attachConfigHandlers();

    // ====== Audio ======
    let audioCtx=null, masterGain=null; 
    const voices = new Map(); // key: hand+finger -> voice
    const settings = {
      instrument:'piano',
      bendSemis:4,
      vibratoHz:0,
      volume:0.85,
      latencyMs:5
    };

    function ensureAudio(){
      if(!audioCtx){
        const opts = { latencyHint: settings.latencyMs/1000 };
        audioCtx = new (window.AudioContext||window.webkitAudioContext)(opts);
        masterGain = audioCtx.createGain(); masterGain.gain.value = settings.volume; masterGain.connect(audioCtx.destination);
      }
    }

    function midiToFreq(m){ return 440 * Math.pow(2,(m-69)/12); }

    function makeVoice(freq){
      const now = audioCtx.currentTime;
      const gain = audioCtx.createGain();
      const filt = audioCtx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=12000; filt.Q.value=0.5;
      gain.connect(filt).connect(masterGain);

      const lfo = audioCtx.createOscillator(); lfo.frequency.value = settings.vibratoHz||0; const lfoGain = audioCtx.createGain(); lfoGain.gain.value = settings.vibratoHz>0? 5: 0; // 5Hz depth in cents aprox
      lfo.connect(lfoGain);

      // Source(s)
      let osc1 = audioCtx.createOscillator(); let osc2 = audioCtx.createOscillator();
      osc1.frequency.value = freq; osc2.frequency.value = freq;
      lfoGain.connect(osc1.frequency); lfoGain.connect(osc2.frequency);

      switch(settings.instrument){
        case 'piano':
          osc1.type='sawtooth'; osc2.type='triangle'; osc2.detune.value=+7; break;
        case 'guitarra':
          osc1.type='sawtooth'; osc2.type='square'; osc2.detune.value=-4; break;
        case 'violin':
          osc1.type='sawtooth'; osc2.type='sawtooth'; osc2.detune.value=+2; filt.frequency.value=6000; filt.Q.value=1.2; break;
        case 'sintetizador':
          osc1.type='sawtooth'; osc2.type='sawtooth'; osc2.detune.value=+11; filt.frequency.value=5000; break;
        case 'squarelead':
          osc1.type='square'; osc2.type='square'; osc2.detune.value=+3; filt.frequency.value=7000; break;
      }

      const mix = audioCtx.createGain(); mix.gain.value=0.8; osc1.connect(mix); osc2.connect(mix); mix.connect(gain);

      // Envelope
      // Configs por instrumento
      let A=0.005,D=0.2,S=0.0,R=0.25, filtStart=9000, filtSustain=2000; 
      if(settings.instrument==='guitarra'){ A=0.002; D=0.25; S=0.0; R=0.2; filtStart=6000; filtSustain=1800; }
      if(settings.instrument==='violin'){ A=0.2; D=0.1; S=0.85; R=0.4; filtStart=5000; filtSustain=3500; }
      if(settings.instrument==='sintetizador'){ A=0.005; D=0.12; S=0.2; R=0.3; filtStart=7000; filtSustain=2500; }
      if(settings.instrument==='squarelead'){ A=0.01; D=0.08; S=0.35; R=0.25; filtStart=6500; filtSustain=3000; }

      function trig(vel=1){
        const t = audioCtx.currentTime;
        const v = Math.min(1, Math.max(0.05, vel));
        gain.gain.cancelScheduledValues(t); filt.frequency.cancelScheduledValues(t);
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(v, t+A);
        gain.gain.linearRampToValueAtTime(S*v, t+A+D);
        filt.frequency.setValueAtTime(filtStart, t);
        filt.frequency.linearRampToValueAtTime(filtSustain, t+A+D);
      }

      function release(){
        const t = audioCtx.currentTime;
        gain.gain.cancelScheduledValues(t);
        gain.gain.setTargetAtTime(0, t, R);
      }

      function setFreq(f){ osc1.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.01); osc2.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.01); }

      osc1.start(); osc2.start(); lfo.start();

      return { gain, filt, osc1, osc2, lfo, lfoGain, trig, release, setFreq };
    }

    function startVoice(key, freq, velocity=1){
      if(!audioCtx) return; 
      let v = voices.get(key);
      if(!v){ v = makeVoice(freq); voices.set(key, v); }
      else { v.setFreq(freq); }
      v.trig(velocity);
    }
    function stopVoice(key){ const v = voices.get(key); if(v){ v.release(); voices.delete(key);} }

    // ====== Gestual ======
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function isFingerExtended(lm, idx){
      // Para √≠ndice, medio, anular, me√±ique: distancia wrist->tip mayor que wrist->pip + margen
      const wrist = lm[0];
      if(idx===0){ // pulgar: usa MCP (2) y tip (4)
        const dTip = dist(lm[4], wrist);
        const dMcp = dist(lm[2], wrist);
        const hand = dist(lm[0], lm[9]); // tama√±o de mano aproximado
        return dTip > dMcp + 0.04*hand;
      }
      const tip = lm[TIP[idx]]; const pip = lm[PIP[idx]];
      const dTip = dist(tip, wrist); const dPip = dist(pip, wrist);
      const hand = dist(lm[0], lm[9]);
      return dTip > dPip + 0.06*hand;
    }

    function handOpeness(lm){ // 0..5 dedos
      let c=0; for(let i=0;i<5;i++) if(isFingerExtended(lm,i)) c++; return c;
    }

    // Escalas y mapeos
    function scaleDegreeToMidi(rootMidi, modeName, degree, octaveShift){
      const scale = MODES[modeName]||MODES.major;
      let idx = Math.max(1, Math.min(degree, scale.length)) - 1; // 0-based
      const base = scale[idx];
      // para grados > longitud de escala, sumar octavas; aqu√≠ limitamos a 1..7
      return rootMidi + base + octaveShift*12;
    }

    function computeFingerMidi(handed, lm, fingerIdx){
      // Config global o override
      const cfg = perFinger[fingerIdx];
      const baseRoot = cfg.override? cfg.overrideRoot : +rootSel.value;
      const baseMode = cfg.override? cfg.overrideMode : modeSel.value;
      const baseOct = cfg.override? +octaveSel.value : +octaveSel.value; // igual octava
      const rootMidi = baseOct*12 + baseRoot; // p.ej. 4*12 + 0 = C4
      let midi = scaleDegreeToMidi(rootMidi, baseMode, cfg.degree, cfg.octaveShift);

      // Bend por posici√≥n vertical del tip
      const y = lm[TIP[fingerIdx]].y; // 0 arriba, 1 abajo
      const centered = (0.5 - y); // positivo al subir
      const semis = Math.round(centered * (settings.bendSemis*2)); // rango aprox
      midi += semis;
      return midi;
    }

    // ====== Video + MediaPipe Hands ======
    const videoEl = document.getElementById('video');
    const canvasEl = document.getElementById('canvas');
    const ctx = canvasEl.getContext('2d');
    let camera=null, hands=null;

    function resizeCanvas(){
      const r = canvasEl.getBoundingClientRect();
      canvasEl.width = r.width; canvasEl.height = r.height;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const fpsText = document.getElementById('fpsText');
    const fpsLed = document.getElementById('fpsLed');
    let lastT = performance.now(); let fps=0;

    const hudInstr = document.getElementById('hudInstr');
    const handsCountEl = document.getElementById('handsCount');
    const stateText = document.getElementById('stateText');

    function draw(results){
      const W = canvasEl.width, H = canvasEl.height;
      ctx.save();
      ctx.clearRect(0,0,W,H);
      ctx.drawImage(results.image, 0,0, W,H);

      if(results.multiHandLandmarks){
        for(let i=0;i<results.multiHandLandmarks.length;i++){
          const lm = results.multiHandLandmarks[i];
          // Dibujar esqueletos
          drawConnectors(ctx, lm, HAND_CONNECTIONS, {lineWidth:2});
          drawLandmarks(ctx, lm, {radius: (data)=>{return data.from? 3: 2;}});

          // Feedback de dedos activos
          for(let f=0; f<5; f++){
            const tip = lm[TIP[f]];
            const x = tip.x * W, y = tip.y*H;
            const ext = isFingerExtended(lm,f);
            ctx.beginPath(); ctx.arc(x,y, ext? 10: 6, 0, Math.PI*2);
            ctx.strokeStyle = ext? '#42d392' : '#888'; ctx.lineWidth = ext? 3:1.5; ctx.stroke();
          }
        }
      }
      ctx.restore();

      // FPS
      const now = performance.now(); const dt = now - lastT; lastT = now; fps = 1000/dt; fpsText.textContent = `FPS: ${fps.toFixed(0)}`;
      fpsLed.className = 'led ' + (fps>25? 'ok' : fps>15? 'warn' : 'bad');
    }

    // Seguimiento de notas activas por dedo/mano
    const lastY = new Map();

    function onResults(results){
      draw(results);

      const LM = results.multiHandLandmarks||[];
      const HD = results.multiHandedness||[];
      handsCountEl.textContent = LM.length;

      // 1) Determinar mano cerrada para mute r√°pido
      let anyOpen=false; for(const lm of LM){ if(handOpeness(lm)>0) { anyOpen=true; break; } }
      if(!anyOpen){ // mano(s) cerrada(s): stop todo
        for(const k of Array.from(voices.keys())) stopVoice(k);
      }

      // 2) Por mano y dedo: si extendido -> nota; si no, stop
      for(let i=0;i<LM.length;i++){
        const lm = LM[i];
        const handed = HD[i]?.label||('mano'+i); // "Right" | "Left"
        for(let f=0; f<5; f++){
          const key = handed+':'+f;
          const ext = isFingerExtended(lm,f);
          if(ext){
            // velocidad ~ |dy|
            const tip = lm[TIP[f]]; const y = tip.y; const prev = lastY.get(key)||y; const vel = Math.min(1, Math.abs(prev - y)*12 + 0.2);
            lastY.set(key,y);
            const midi = computeFingerMidi(handed,lm,f);
            const freq = midiToFreq(midi);
            startVoice(key, freq, vel);
          }else{
            stopVoice(key); lastY.delete(key);
          }
        }
      }
    }

    // ====== Controles UI ======
    const btnStart = document.getElementById('btnStart');
    const btnMute = document.getElementById('btnMute');
    const instrumentSel = document.getElementById('instrumentSel');
    const modeSel = document.getElementById('modeSel');
    const octaveSel = document.getElementById('octaveSel');
    const bendRange = document.getElementById('bendRange');
    const vibRange = document.getElementById('vibRange');
    const gainRange = document.getElementById('gainRange');
    const latencyRange = document.getElementById('latencyRange');
    const permStatus = document.getElementById('permStatus');
    const permStatusLed = document.getElementById('permStatusLed');

    instrumentSel.addEventListener('change', ()=>{ settings.instrument = instrumentSel.value; hudInstr.textContent = instrumentSel.options[instrumentSel.selectedIndex].text; });
    bendRange.addEventListener('input', ()=> settings.bendSemis = +bendRange.value );
    vibRange.addEventListener('input', ()=>{ settings.vibratoHz = +vibRange.value; });
    gainRange.addEventListener('input', ()=>{ settings.volume = +gainRange.value; if(masterGain) masterGain.gain.value=settings.volume; });
    latencyRange.addEventListener('input', ()=>{ settings.latencyMs = +latencyRange.value; });

    let started=false;
    btnStart.addEventListener('click', async ()=>{
      try{
        ensureAudio(); await audioCtx.resume();
        // Inicializa MediaPipe Hands
        hands = new Hands({ locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        // C√°mara
        const cam = new Camera(videoEl, {
          onFrame: async () => {
            await hands.send({ image: videoEl });
          },
          width: 1280,
          height: 720
        });
        await cam.start(); camera = cam;
        btnMute.disabled = false; btnStart.disabled = true; started=true;
        permStatus.textContent = 'OK: c√°mara y audio activos'; permStatusLed.className='led ok';
        stateText.textContent = 'Mueve los dedos. Cada dedo dispara una nota; subir/bajar cambia el tono.';
      }catch(err){
        console.error(err);
        permStatus.textContent = 'Error de permisos o c√°mara'; permStatusLed.className='led bad';
        stateText.textContent = 'Revisa permisos del navegador para c√°mara y sonido.';
      }
    });

    let muted=false; btnMute.addEventListener('click', ()=>{
      if(!masterGain) return;
      muted = !muted; masterGain.gain.value = muted? 0 : settings.volume;
      btnMute.textContent = muted? 'üîä Reactivar' : 'üîá Silencio';
    });

    // Evitar suspensi√≥n de audio en m√≥viles por falta de gesto
    window.addEventListener('touchstart', ()=>{ if(audioCtx){ audioCtx.resume(); } }, {passive:true});

  })();
  </script></body>
</html>
